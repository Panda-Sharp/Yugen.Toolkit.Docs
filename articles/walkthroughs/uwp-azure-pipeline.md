# CI/CD UWP: Build, Sign with certificate, Release to App Center and Store with Azure Pipelines

# Creating a build pipeline

Build pipelines can be created under the `Pipelines > Pipelines` section of your project on Azure DevOps, and click on `New Pipeline`:

1. `Where is your code?` You can choose from among many options, like Azure Repos, GitHub, BitBucket, Other Git and Subversion. In this walkthrough we're going to use the new default `YAML` optionL, which is a markup language.
2. `Select a repository`Choose the repository
3. `Configure your pipeline` Azure Pipeline will propose a set of templates for different project types. Each of them will create a basic YAML file with some tasks already configured. In our scenario, the template to choose is `Universal Windows Platform`, which will compile our UWP or Windows Application Packaging Project and create an MSIX.
4. The template will create the following YAML file:

```
    # Universal Windows Platform
    # Build a Universal Windows Platform project using Visual Studio.
    # Add steps that test and distribute an app, save build artifacts, and more:
    # https://aka.ms/yaml

    trigger:
    - master

    pool:
      vmImage: 'windows-latest'

    variables:
      solution: '**/*.sln'
      buildPlatform: 'x86|x64|ARM'
      buildConfiguration: 'Release'
      appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'

    steps:
    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(solution)'

    - task: VSBuild@1
      inputs:
        platform: 'x86'
        solution: '$(solution)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:AppxBundlePlatforms="$(buildPlatform)" 
                      /p:AppxPackageDir="$(appxPackageDir)" 
                      /p:AppxBundle=Always 
                      /p:UapAppxPackageBuildMode=StoreUpload'
```

## The configuration

The `trigger` section is used to enable continuous integration and specifies the criteria used to trigger a new build. By default, it contains the name of the branch we’re building `master`, which means that every commit to this branch will trigger a new build. In my implementation I'm going to change it to `release/*` so it will be triggered only on a commit in this branch,

```
    trigger:
    - release/*
```

The `pool` section contains the configuration of the agent that will execute the build. With `windows-latest` we specify that we want to use the latest Windows image.

The `variables` section defines a set of parameters that are leveraged during the build
process. Specifically:
- `solution` defines which solution we want to build. By default, the pipeline will build all the solutions included in the project.
- `buildPlatform` defines which architecture we want to support inside the package.
- `buildConfiguration` is the Visual Studio configuration used for the build.
- `appxPackageDir` is the folder where the package will be created if the build is
successful.

## The steps
The steps section contains the tasks that will be performed one after the other. Each task has a unique identifier and a set of properties to customize it. 
1. `NuGetToolInstaller` will download the most recent version of NuGet
2. `NuGetCommand` restore all the dependencies in the project. 
3. `VSBuild` will build the project and create an MSIX package.

### Customizing the build 

1. Disable the package signing. By default, MSIX packages are signed with a self-signing certificate generated by Visual Studio during the build process. However, signing the package during the build process isn't a good practice because we would need to upload the certificate to the repository. This means every developer working on the project will have access to the certificate, increasing the risk of identity theft. As such, the recommended approach is to sign the package in the release pipeline and store the certificate in a safe way. We're going to see how to do this later in the chapter. For the moment, just disable the signing during the compilation by adding the `/p:AppxPackageSigningEnabled=false` parameter to the `msBuildArgs` property of the `VSBuild` task.

2. Upload the `artifacts`, you can think of the hosted agent as a sort of virtual machine. Every time a new build is triggered, a new instance is created, which takes care of executing all the tasks, one after the other, and then it's disposed of at the end. The consequence is that, if we don't store the output of the build somewhere, it will be lost as soon as the hosted agent is disposed of. Azure DevOps offers its own cloud storage for storing the artifacts. Artifacts are available to the developer for manual download and are important for building a release pipeline. In a CD pipeline, in fact, the deployment is typically kicked off when a new artifact is available as a consequence of a CI pipeline that has been successfully completed. To achieve this goal, you will need to add the following task as the last step.

```
    - task: PublishBuildArtifacts@1
    inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)\AppxPackages'
        ArtifactName: 'drop'
```

Now our pipeline YAML file should look like this:

```
    # Universal Windows Platform
    # Build a Universal Windows Platform project using Visual Studio.
    # Add steps that test and distribute an app, save build artifacts, and more:
    # https://aka.ms/yaml

    trigger:
    - release/*

    pool:
      vmImage: 'windows-latest'

    variables:
      solution: '**/*.sln'
      buildPlatform: 'x86|x64|ARM'
      buildConfiguration: 'Release'
      appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'

    steps:   

    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(solution)'

    - task: VSBuild@1
      inputs:
        platform: 'x86'
        solution: '$(solution)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:AppxBundlePlatforms="$(buildPlatform)" 
                      /p:AppxPackageDir="$(appxPackageDir)" 
                      /p:AppxBundle=Always 
                      /p:UapAppxPackageBuildMode=StoreUpload 
                      /p:AppxPackageSigningEnabled=false'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)\AppxPackages'
        ArtifactName: 'drop'
```

Once you have finished editing the YAML file, you can click `Save and run`. The YAML file will be saved in the root of your repository, and the build will be triggered. You will be able to follow the build step by step, thanks to real-time logging. If the build is successful, you’ll be able to access the artifacts using the `Artifacts` button that will appear at the top of the build details page. From there, you will be able to explore and download the files that have been created.


Note: Since the YAML file is stored in the repository of your project, you can edit it on your local machine using an editor like Visual Studio or Visual Studio Code. The latter also offers an extension that adds IntelliSense support for the various tasks offered by Azure Pipeline.

## Setting the package version 

### Option 1. Date versioning

If you check the artifact, you will notice that the MSIX package has been generated using the version number that is declared in the manifest of your project. By default, however, the version number will not change for future builds, as the build environment is not persisted between them. It's our duty to manually update the manifest every time we push some code to the repository. However, this approach can lead to many problems. If we forget to update the number, and we generate an update with the same version number as the prevision one, we will break the update chain.

The solution is to leverage the build number generated by Azure DevOps to update the package version also, so that it will be automatically increased at every execution. However, there’s a catch. By default, Azure DevOps uses the following expression to generate a build number. 

```
    $(date:yyyyMMdd)$(rev:.r)
```

The dollar sign is used by Azure DevOps to reference variables, which can be configured on the portal. However, some of them are already built into Azure DevOps, like the one used for the date in the expression above. You can find the full list [here](https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml). The expression will generate a build number like the following.

```
    20190504.1
```

This build number, however, isn’t compatible with the version number required by MSIX packages, which must follow the convention `x.y.z.0`. We can change the build number by editing the YAML file and modifying the build configuration. To achieve this goal, go back to `Pipelines > Builds` in your Azure DevOps project, locate the build pipeline you previously created, and click `Edit`. You will get access to the advanced YAML editor. To define the new build number, you have to add a new entry before the steps section using the following snippet.

```
    name: $(date:yyyy).$(Month)$(rev:.r).0
```

With the `name` entry, we’re defining a new versioning for the build number. This time, we’re generating a version that is compatible with the MSIX requirements. 


### Option 2. Manual versioning 

1. Add the following variables 
```
    appxmanifest: '**/*.appxmanifest'
    versionNumber: 'Set dynamically below in a task'
```

2. Add the following snippet  `name: '$(Rev:r)'`
3. introduce the following powrshell script as first step

```
    - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
        [xml] $manifestXml = Get-Content '$(appxmanifest)'
        $version = [version]$manifestXml.Package.Identity.Version

        [string] $newVersion = "{0}.{1}.{2}.{3}" -f $version.Major, $version.Minor, $(Build.BuildNumber), 0
        Write-Host "Setting the release version number variable to '$newVersion'."
        Write-Host "##vso[task.setvariable variable=versionNumber]$newVersion"

        Write-Host "Setting the name of the build to '$newVersion'."
        Write-Host "##vso[build.updatebuildnumber]$newVersion"
```

this task take the current `major` and `minor` version from the current manifest and increment the `revision` according to the build number

3. Now our yaml file will look like this: 

## Apply Build number to manifest


The last step is to apply this build number to the manifest of our MSIX package. We can use a task created by a third-party developer. Save the YAML file you have updated, and then go back to the Azure DevOps dashboard. Locate the marketplace icon at the top and choose `Browse marketplace`. [link](https://marketplace.visualstudio.com/)

Search for an extension called Manifest Versioning Build Task by Richard Fennell, [link](https://marketplace.visualstudio.com/items?itemName=richardfennellBM.BM-VSTS-Versioning-Task), click it,
and then click `Get it free`. You will initialize the process to add the extension to your Azure
DevOps account. Once the extension has been installed, you can go back to the pipeline, click
`Edit`, and add the following step before the `VSBuild` step.

```
    - task: VersionAPPX@2
    displayName: 'Version MSIX'
```

This task doesn’t require any special parameter. It will simply edit the manifest of your project and apply the build number as the version.

Now our pipeline YAML file should look like this:

### Option 1

```
    # Universal Windows Platform
    # Build a Universal Windows Platform project using Visual Studio.
    # Add steps that test and distribute an app, save build artifacts, and more:
    # https://aka.ms/yaml

    trigger:
    - release/*

    pool:
      vmImage: 'windows-latest'

    variables:
      solution: '**/*.sln'
      buildPlatform: 'x86|x64|ARM'
      buildConfiguration: 'Release'
      appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'

    name: $(date:yyyy).$(Month)$(rev:.r).0

    steps:   

    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(solution)'

    - task: VersionAPPX@2
      displayName: 'Version MSIX'

    - task: VSBuild@1
      inputs:
        platform: 'x86'
        solution: '$(solution)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:AppxBundlePlatforms="$(buildPlatform)" 
                      /p:AppxPackageDir="$(appxPackageDir)" 
                      /p:AppxBundle=Always 
                      /p:UapAppxPackageBuildMode=StoreUpload 
                      /p:AppxPackageSigningEnabled=false'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)\AppxPackages'
        ArtifactName: 'drop'
```

### Option 2

```
    # Universal Windows Platform
    # Build a Universal Windows Platform project using Visual Studio.
    # Add steps that test and distribute an app, save build artifacts, and more:
    # https://aka.ms/yaml

    trigger:
    - release/*

    pool:
      vmImage: 'windows-latest'

    variables:
      solution: '**/*.sln'
      buildPlatform: 'x86|x64|ARM'
      buildConfiguration: 'Release'
      appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'
      appxmanifest: '**/*.appxmanifest'
      versionNumber: 'Set dynamically below in a task'

    name: '$(Rev:r)'

    steps:   

    - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
        [xml] $manifestXml = Get-Content '$(appxmanifest)'
        $version = [version]$manifestXml.Package.Identity.Version

        [string] $newVersion = "{0}.{1}.{2}.{3}" -f $version.Major, $version.Minor, $(Build.BuildNumber), 0
        Write-Host "Setting the release version number variable to '$newVersion'."
        Write-Host "##vso[task.setvariable variable=versionNumber]$newVersion"

        Write-Host "Setting the name of the build to '$newVersion'."
        Write-Host "##vso[build.updatebuildnumber]$newVersion"

    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(solution)'

    - task: VersionAPPX@2
      displayName: 'Version MSIX'

    - task: VSBuild@1
      inputs:
        platform: 'x86'
        solution: '$(solution)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:AppxBundlePlatforms="$(buildPlatform)" 
                      /p:AppxPackageDir="$(appxPackageDir)" 
                      /p:AppxBundle=Always 
                      /p:UapAppxPackageBuildMode=StoreUpload 
                      /p:AppxPackageSigningEnabled=false'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)\AppxPackages'
        ArtifactName: 'drop'
```
